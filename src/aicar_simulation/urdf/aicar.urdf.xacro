<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="aicar">
    <!-- 参数 -->
    <!-- 1.车辆尺寸 -->
    <xacro:property name="car_length" default="1.2" />
    <xacro:property name="car_width" default="0.8" />
    <xacro:property name="car_height" default="0.4" />


    <!-- 2.轮子尺寸 -->
    <xacro:property name="wheel_width" default="0.1" />
    <xacro:property name="wheel_radius" default="0.18" />

    <!-- 新增：前后轮轴心到车体中心的距离 -->
    <xacro:property name="axle_offset" default="0.5" />
    <!-- 修正轴距公式：前轴到后轴的距离 -->
    <xacro:property name="wheel_base" default="${2 * axle_offset}" />

    <!-- 3.离地间隙 -->
    <xacro:property name="clearance" default="0.10" />

    <!-- 4.惯性矩阵宏 (封装好的物理公式) -->
    <!-- Box 的惯性矩阵 -->
    <xacro:macro name="box_inertia" params="m w h d">
        <inertial>
            <mass value="${m}" />
            <inertia
                ixx="${(m/12) * (w*w + h*h)}" ixy="0.0" ixz="0.0"
                iyy="${(m/12) * (d*d + h*h)}" iyz="0.0"
                izz="${(m/12) * (w*w + d*d)}" />
        </inertial>
    </xacro:macro>

    <!-- Cylinder 的惯性矩阵 -->
    <xacro:macro name="cylinder_inertia" params="m r h">
        <inertial>
            <mass value="${m}" />
            <inertia
                ixx="${(m/12) * (3*r*r + h*h)}" ixy="0.0" ixz="0.0"
                iyy="${(m/12) * (3*r*r + h*h)}" iyz="0.0"
                izz="${(m/2) * (r*r)}" />
        </inertial>
    </xacro:macro>

    <!-- 5.虚拟根节点(投影点) -->
    <link name="base_footprint" />

    <!-- 6.车身 Link -->
    <link name="base_link">
        <visual>
            <geometry>
                <box size="${car_length} ${car_width} ${car_height}" />
            </geometry>
            <!-- 材质颜色(可选) -->
            <material name="bule">
                <color rgba="0.1 0.1 1.0 1.0" />
            </material>
        </visual>

        <collision>
            <geometry>
                <box size="${car_length} ${car_width} ${car_height}" />
            </geometry>
        </collision>

        <xacro:box_inertia m="20.0" w="${car_width}" h="${car_height}" d="${car_length}" />
    </link>

    <!-- 舵机驱动 link （虚拟的转向杆） -->
    <link name="steer_link">
        <inertial>
            <mass value="1.0" />
            <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01" />
        </inertial>
    </link>
    <joint name="steer_joint" type="fixed">
        <parent link="base_link" />
        <child link="steer_link" />
        <!-- 放在前轴的中心点，用于计算转向几何 -->
        <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0" />
    </joint>

    <!-- 7.关节:把车身驾在 Footprint 上 -->
    <joint name="base_joint" type="fixed">
        <parent link="base_footprint" />
        <child link="base_link" />
        <!-- Z轴抬高: 轮子半径 + 离地间隙 -->
        <origin xyz="0.0 0.0 ${car_height/2 + clearance}" rpy="0.0 0.0 0.0" />
    </joint>

    <!-- 后轮宏：只有滚动 -->
    <xacro:macro name="rear_wheel" params="prefix x_reflect y_reflect">
        <link name="${prefix}_wheel_link">
            <visual>
                <origin xyz="0.0 0.0 0.0" rpy="${pi/2} 0.0 0.0" />
                <geometry>
                    <cylinder radius="${wheel_radius}" length="${wheel_width}" />
                </geometry>
            </visual>
            <collision>
                <origin xyz="0.0 0.0 0.0" rpy="${pi/2} 0.0 0.0" />
                <geometry>
                    <cylinder radius="${wheel_radius}" length="${wheel_width}" />
                </geometry>
            </collision>
            <xacro:cylinder_inertia m="3.0" r="${wheel_radius}" h="${wheel_width}" />
        </link>

        <joint name="${prefix}_wheel_joint" type="continuous">
            <parent link="base_link" />
            <child link="${prefix}_wheel_link" />
            <origin
                xyz="${x_reflect * (car_length/2 - 0.1)} ${y_reflect * (car_width/2 + wheel_width/2)} ${wheel_radius - (clearance + car_height/2)}"
                rpy="0 0 0" />
            <axis xyz="0 1 0" />
        </joint>
        <gazebo reference="${prefix}_wheel_link">
            <mu1>1.0</mu1>
            <mu2>1.0</mu2>
            <kp>1000000.0</kp>
            <kd>1.0</kd>
        </gazebo>
    </xacro:macro>

    <!-- 前轮宏：可以转向和滚动 -->
    <xacro:macro name="front_wheel" params="prefix x_reflect y_reflect">
        <!-- 转向节link -->
        <link name="${prefix}_steering_hinge">
            <xacro:cylinder_inertia m="0.1" r="0.05" h="0.05" />
        </link>

        <!-- 转向关节：绕Z轴旋转 -->
        <joint name="${prefix}_steering_joint" type="revolute">
            <parent link="base_link" />
            <child link="${prefix}_steering_hinge" />
            <origin
                xyz="${x_reflect * (car_length/2 - 0.1)} ${y_reflect * (car_width/2 + wheel_width/2)} ${wheel_radius - (clearance + car_height/2)}"
                rpy="0.0 0.0 0.0" />
            <axis xyz="0 0 1" />
            <limit lower="-0.5235" upper="0.5235" effort="1000.0" velocity="100.0" />
            <!-- 增加以下这行：damping 是阻尼，friction 是静态摩擦 -->
            <dynamics damping="10.0" friction="1.0" />
        </joint>

        <!-- 轮子link -->
        <link name="${prefix}_wheel_link">
            <visual>
                <origin xyz="0.0 0.0 0.0" rpy="${pi/2} 0.0 0.0" />
                <geometry>
                    <cylinder radius="${wheel_radius}" length="${wheel_width}" />
                </geometry>
            </visual>
            <collision>
                <origin xyz="0.0 0.0 0.0" rpy="${pi/2} 0.0 0.0" />
                <geometry>
                    <cylinder radius="${wheel_radius}" length="${wheel_width}" />
                </geometry>
            </collision>
            <xacro:cylinder_inertia m="3.0" r="${wheel_radius}" h="${wheel_width}" />
        </link>
        <!-- 轮子滚动关节： 绕y轴旋转 -->
        <joint name="${prefix}_wheel_joint" type="continuous">
            <parent link="${prefix}_steering_hinge" />
            <child link="${prefix}_wheel_link" />
            <axis xyz="0 1 0" />
        </joint>
        <gazebo reference="${prefix}_wheel_link">
            <mu1>1.0</mu1>
            <mu2>1.0</mu2>
            <kp>1000000.0</kp>
            <kd>10.0</kd>
        </gazebo>
    </xacro:macro>


    <!-- 9.调用宏生成4个轮子 -->
    <xacro:front_wheel prefix="front_left" x_reflect="1" y_reflect="1" />
    <xacro:front_wheel prefix="front_right" x_reflect="1" y_reflect="-1" />
    <xacro:rear_wheel prefix="rear_left" x_reflect="-1" y_reflect="1" />
    <xacro:rear_wheel prefix="rear_right" x_reflect="-1" y_reflect="-1" />


    <!-- 10. Gazebo阿克曼驱动插件 -->
    <gazebo>
        <plugin name="ackermann_drive" filename="libgazebo_ros_ackermann_drive.so">
            <ros>
                <!-- 推荐在ROS 2 Humble中使用精确的话题重映射 -->
                <remapping>cmd_vel:=/cmd_vel</remapping>
                <remapping>odom:=/odom</remapping>
            </ros>

            <update_rate>100.0</update_rate>

            <!-- 关节名称 -->
            <!-- 转向关节 -->
            <left_steering_joint>front_left_steering_joint</left_steering_joint>
            <right_steering_joint>front_right_steering_joint</right_steering_joint>

            <!-- 驱动关节: 这里我们将驱动也放在前轮上，阿克曼模型通常是前轮转向、后轮驱动或四轮驱动 -->
            <!-- 如果您希望是后轮驱动，请确保模型物理属性和PID参数适应这种情况 -->
            <front_left_joint>front_left_wheel_joint</front_left_joint>
            <front_right_joint>front_right_wheel_joint</front_right_joint>
            <rear_left_joint>rear_left_wheel_joint</rear_left_joint>
            <rear_right_joint>rear_right_wheel_joint</rear_right_joint>
            <!-- 几何参数 -->
            <wheel_separation>${car_width + wheel_width}</wheel_separation>
            <wheel_diameter>${2 * wheel_radius}</wheel_diameter>
            <!-- 轴距的计算是前后轮转向轴中心的距离，您的计算是正确的 -->
            <wheel_base>${2 * (car_length/2 - 0.1)}</wheel_base>

            <!-- 限制参数 -->
            <max_steer>0.5235</max_steer>
            <max_speed>20.0</max_speed>

            <!-- PID增益 -->
            <left_steering_pid_gain>4000 0.5 50</left_steering_pid_gain>
            <right_steering_pid_gain>4000 0.5 50</right_steering_pid_gain>
            <!-- 驱动 PID： 后驱重点给这两个 -->
            <linear_velocity_pid_gain>50 0 0</linear_velocity_pid_gain>
            <!-- 输出 -->
            <publish_odom>true</publish_odom>
            <publish_odom_tf>true</publish_odom_tf>
            <publish_wheel_tf>true</publish_wheel_tf>
            <publish_distance>true</publish_distance>

            <odometry_frame>odom</odometry_frame>
            <robot_base_frame>base_footprint</robot_base_frame>
        </plugin>
    </gazebo>

</robot>